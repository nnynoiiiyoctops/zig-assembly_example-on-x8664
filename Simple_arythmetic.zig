const std_lib = @import("std");
const expect = std_lib.testing.expect;
  //volatile = указание компилятору не оптимизировать и не выкидывать эти куски кода
  //Общий синтаксис выглядит так
  //asm( строка : выходы : входы : clobbers );
  //Но чаще вы будите видеть
  //asm volatile(
  //\\asm code
  // : [ret] "constraint" ( -> type),  //zig:16:11: error: inline assembly allows up to one output value
                                       //issue215((((
                                       //Может быть только 1 выход
  // Хотя будут показаны примеры обратного  
  // : вход_1,                         //Синтаксис входных данных зависит от решения issue 215. Ознакомьтесь если интересно
  //   вход_2,                         //https://github.com/ziglang/zig/issues/215
  //   ...   ,
  //   вход_n
  // : .{ .rcx = true, .r11 = true } ); //Это лишь пример
                                        //Но тут показано, что эти регистры будут изменены после этой вставки кода
                                        //Например этот "clobbers" говорит что после нашего кода поменяются
                                        //регистры rcx и r11
                                        //Или  .{ .memory = true }, если будет изменена память во вне
test "Первая ассемблерная вставка" {
  var a: u64 = 0;
  var b: u64 = 0;
  asm volatile(
      \\mov   $2,      %[a] //a = 2
      \\mov   $3,      %[b] //b = 3
      : [a] "+r" (a),      //а - доступен для чтения и записи
        [b] "+r" (b),      //b - доступно для записи в него
                                //Всё о чём говорит эта строка - так о том, что данная ассемблерная вставка возвращает значение в регистр rax
                                //И тип этого значения - u64
      
      :                   //Мы сюда ничего не передаём. Поэтому секция ввода будет пуста
                          //Хотя и пишем в переданные переменные
                          //Но если мы запишем их здесь. То результат в них не запишется. В этом вы можете убедиться
                          //ознакомившись с файлом Change_constant.zig в этой же директории
      : .{}               //Тут перечисляются регистры которые будут изменены. Но изменены во вне
                          //Обращаю внимание на то, что тут не используется регистр RAX и из вне он не изменен.
                          //Хочу отметить что активно эта секция будет использоваться либо при вызове функции.
                          //Либо при системных выховах
                          // Хочу отметить что при системных вызовах может меняться память. Для этого есть поле
                          // .memory которому задается значение true
  );
  // "=r" - ввод в регистр/переменную
  // "+r" - ввод и вывод из регистра/переменной
  // "m"  - memory. И такое есть. Но это будет не в этом файле
  //Так же стоит уточнить что r - любой регистр. Тогда как для ограничения конкретного регистра, его следует обрамлять с помощью {}
  // "{rax}" | "={rax}" | "+{rax}" тоже валидно

  // Лучше всего будет ознакомиться с
  // https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html
  // https://releases.llvm.org/10.0.0/docs/LangRef.html#inline-asm-constraint-string

  // Синтаксис взят от GCC.
  // А ограничения, clobbers, Constraint взяты с llvm
  // Насколько я разобрался
  try expect( a == 2 );
  try expect( b == 3 );

}

test "Сложение" {

  const result = asm volatile(
      \\add    %%rax,    %%rdx  //Результат пишется во второй аргумет
      : [ret] "={rdx}" ( -> u64 )
      : [_]   "{rax}"  ( 2 ),
        [_]   "{rdx}"  ( 3 )
      : .{ .rax = true } );

  std_lib.debug.print( "{d} ", .{result} );
  try expect( result == 5 );
}

test "Вычитание" {
  const result: u64 = asm volatile(
      \\mov   $20,       %%rax
      \\mov   $10,       %%rdx
      \\sub   %%rdx,     %%rax //Почему-то в sub результат во второй аргумент пишется
      : [ret] "={rax}" ( -> u64)
      : [_] "{rax}"  (20),   // Имена в ассемблерных вставках могут отличаться от переменных, с которыми вы их "свяжите"
        [_] "{rdx}"  (10),   // Вот наглядный пример      
      : .{ .rax = true }     // Тут должны были быть clobbers. Но их можно опустить. Как математики опускают скобки у "sin 2x"
                             // Но из опыта работы с функцией print знаем что можно оставить такую безымянную структуру
                             // А за простое : компилятор даст по шее
  );

  try expect( result == 10 );
}


test "Знаковое умножение" {
  const result: u64 = asm volatile(
      \\imul   %%rdx,    %%rax  //b = a * b Тут тоже результат во второй аргумент
      : [ret] "={rax}" ( -> u64 )
      : [_] "{rax}" (2),
        [_] "{rdx}" (4),
      : .{ .rax = true, .rdx = true}
  );

  try expect( result == 8 );

}

  
  // asm volatile(
  //   \\
  //     :
  //     :
  //     : .{}
  // );

  // try writer.interface.print("mul:   |a: {d}|b: {d}|\n", .{ a, b });
  // try writer.interface.flush();

//Далее буду делать тесты. Так как это проще для восприятия и сиполнения

test "mul instruction" {
  const a: u64 = asm volatile(
      \\mul    %%rdx
      : [ret]  "={rax}"  (-> u64)
      : [_]    "{rax}"  ( 2 ),
        [_]    "{rdx}"  ( 3 )
      : .{ .rax = true, .rdx = true }
  );

  try expect( a == 6 );
}
