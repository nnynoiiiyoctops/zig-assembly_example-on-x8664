const std_lib = @import("std");

pub fn main() !void {
  var a: i64 = 0;
  var b: i64 = 0;

  var buffer: [128]u8 = undefined;
  var writer: std_lib.fs.File.Writer = .init( std_lib.fs.File.stdout(), &buffer );

  try writer.interface.print("\nbegin: |a: {d}|b: {d}|\n", .{ a, b });
  try writer.interface.flush();

  //volatile = указание компилятору не оптимизировать и не выкидывать эти куски кода
  //Общий синтаксис выглядит так
  //asm( строка : выходы : входы : clobbers );
  //Но чаще вы будите видеть
  //asm volatile(
  //\\asm code
  // : выход_1,
  //   выход_2,
  //   ...    ,
  //   выход_n
  // : вход_1,        //Синтаксис входных данных зависит от решения issue 215. Ознакомьтесь если интересно
  //   вход_2,        //https://github.com/ziglang/zig/issues/215
  //   ...   ,
  //   вход_2
  // : .{ .rcx = true, .r11 = true } ); //Это лишь пример
                                        //Но тут показано, что эти регистры будут изменены после нашего кода
                                        //Но не обязательно нашим кодом
                                        //Например этот "clobbers" говорит что после нашего кода поменяются
                                        //регистры rcx и r11
  
  const first_asm = asm volatile(
      \\mov   $2,      %[a] //a = 2
      \\mov   $3,      %[b] //b = 2
      \\add   %[a],    %[b] //a = a + b
      : [a] "+r" (a),     //а - доступен для чтения и записи
        [b] "=r" (b),     //b - доступно для записи в него
      :                   //Мы сюда ничего не передаём. Поэтому секция ввода будет пуста
      : .{ .rax = true }  //Тут перечисляются регистры которые будут изменены. Но изменены из вне
                          //Обращаю внимание на то, что тут не используется регистр RAX и из вне он не изменен.
                          //Хочу отметить что активно эта секция будет использоваться либо при вызове функции.
                          //Либо при системных выховах
                          // Хочу отметить что при системных вызовах может меняться память. Для этого есть поле
                          // .memory = true
  );
  // "=r" - ввод в регистр/переменную
  // "+r" - ввод и вывод из регистра/переменной
  //Так же стоит уточнить что r - любой регистр. Тогда как для ограничения конкретного регистра, его следует обрамлять с помощью {}
  // "{rax}" | "={rax}" | "+{rax}" тоже валидно

  try writer.interface.print("\n asm type is: {any}\n", .{ @TypeOf(first_asm) });
  try writer.interface.flush();
  
  try writer.interface.print("add:   |a: {d}|b: {d}|\n", .{ a, b });
  try writer.interface.flush();
  
  asm volatile(
      \\mov   $20,       %[val_a] //a = 20
      \\mov   $10,       %[val_b] //b = 10
      \\sub   %[val_a],  %[val_b] //a = a - b
      : [val_a] "+r"  (a),  // Имена в ассемблерных вставках могут отличаться от переменных, с которыми вы их "свяжите"
        [val_b] "=r"  (b),  // Вот наглядный пример
      :                     // Всё ещё не вводим ничего
      : .{}                 // Тут должны были быть clobbers. Но их можно опустить. Как математики опускают скобки у "sin 2x"
                            // Но из опыта работы с функцией print знаем что можно оставить такую безымянную структуру
                            // А за простое : компилятор даст по шее
  );

  try writer.interface.print("sub:   |a: {d}|b: {d}|\n", .{ a, b });
  try writer.interface.flush();

  asm volatile(
      \\mov    $2,    %[a]  //a = 2
      \\mov    $4,    %[b]  //b = 4
      \\imul   %[a],  %[b]  //b = a * b
      : [a] "+r" (a),
        [b] "=r" (b)
      :                     // Несмотря на то, что тут читаются и записываются переменные.
                            // Эти данные принято считать входными
                            // Так как после исполнения кода, они не оставят данных в регистрах
      : .{}
  );

  try writer.interface.print("imul:  |a: {d}|b: {d}|\n", .{ a, b });
  try writer.interface.flush();

  asm volatile(
      \\xor  %%rax,   %%rax  //Умные дядьки говорят что это быстрее чем \\mov  $0,  %%rax. Результат 1, к слову
      // Это тут не пригодится. Просто пока я при памяти решил записать
      \\mov    $8,    %[a]  //a = 8
      \\mul    %[a]         //a = a * a
      : [a] "+r" (a),
        [b] "=r" (b)
      :
      : .{}
  );
  //Тут я должен сказать что большинство этих инструкций я тыкаю наугад)
  //Так что вы выбрали крайне сомнительный источник для обучения
  
  try writer.interface.print("mul:   |a: {d}|b: {d}|\n", .{ a, b });
  try writer.interface.flush();

  
  asm volatile(
      \\xor  %%rax,   %%rax  //Умные дядьки говорят что это быстрее чем \\mov  $0,  %%rax. Результат 1, к слову
      // Это тут не пригодится. Просто пока я при памяти решил записать
      \\mov    $8,    %[a]  //a = 2
      \\imul   %[a],  %[a]  //Оказывается и так вот можно. 
      : [a] "+r" (a)
      :
      : .{}
  );
  
  try writer.interface.print("mul2:  |a: {d}|b: {d}|\n", .{ a, b });
  try writer.interface.flush();

  // asm volatile(
  //   \\
  //     :
  //     :
  //     : .{}
  // );

  // try writer.interface.print("mul:   |a: {d}|b: {d}|\n", .{ a, b });
  // try writer.interface.flush();
  
  return;
} 
