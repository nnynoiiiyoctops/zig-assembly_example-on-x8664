const std_lib = @import("std");
const expect  = std_lib.testing.expect;


//Тут будет небольшое объяснение для людей в ассемблере не сведующих.
//Это даст базовое представление. Так как иным я сам и не обладаю,
//в веду того, что самоучка

//Главный и весьма очевидный вопрос:

//Q: Ну и зачем?

//A: Не менее тупой и очевидный ответ - раз есть значит нада!.
//Как минимум в std_lib вы можете найти множество ассемблерных вставок
//Правда большинство из них - это syscall и leaq (команда взятия адреса)
//Да. Там именно leaq, а не &variable_name. Этот пример из std_lib.gpu
//Хотя те же сисколы вы можете обнаружить и во множестве других мест

//Стоит отметить что если вы хотите писать без библиотек - без ассемблерных
//вставок не сможете.

//Так же стоит отметить что и при написании собственных библиотек вы либо
//опираетесь на иные библиотеки или тыкаетесь в assembler. В иных случаях
//это не нужно. В конце то концов хотя бы для общего развития.

//Если вы решили написать свою ОС у вас нет другого способа взаимодействовать
//с указателями на 0 и близкими к нему данными


//=========ЗОЧЕМ?==========
//Сам по себе ассемблер, по своей низкоуровневости - предпоследний.
//Ниже него только непесредственно опкоды и записаь в hex-редакторах
//16ричными цифрами(чтобы писать по 4 нолика или единички за раз)
//Его вставки не просто так вставки. Практика показывает что нужен он
//редко, местами. Ну и зачем?

//Очень часто слышу мнение, что быстрее компилятора код человек на напишет

//Само по себе мнение странное. Так как компилятор - тоже программа.
//Он тоже содержит ошибки, он может недостаточно оптимизировать код.
//Он всё ещё достаточно хорош но не всемогущь. Следует это помнить.

//Да и хочу отметить, что компиляторы становятся всё лучше. Значит есть
//люди, что пишут их. И пишут порой на ассемблере.

//Да и я не знаю языка программирования, который бы сисколы делать, без
//ассемблерных вставок.

//Последний аргумент - читать дизасм. Из-за того что компилятор оптимизирует
//код - его нельзя вернуть в тот же, в котором вы его записали, если конечно
//вы не использовали флаг -O0 или дебаг режим сборки в Zig. Так вот! Единственный
//сопособ понять что же там в бинарнике провести дизасемблирование. То есть перевести
//машинные команды напрямую в мнемоники ассемблера. Как минимум это позволит вам
//точно понять что делает итоговый бинарник и как его покорёжил компилятор


//===========ЧТО_ЖЕ_ТАКОЕ_РЕГИСТР==========
//Я надеюсь вам известно, что ваши программы исполняются процессором?
//Отлично!)
//Регистры - часть процессора, которая выполняет свою работу по краткосрочному
//Хранению данных между исполнением команд этого самого процессора
//Их не обязательно запоминать. Достаточно иметь при себе табличку.
//Хотя если вы по какой-то причине будете очень часто работать с ассемблером
//определенной архитектуры - вы быстро выучите его регистры.

//Определение с вики вы и сами прочитаете. Я лишь оставлю тут табличку для x64_64
// Биты 63-0     Биты 31-0     Биты 15-0     Биты 15-8     Биты 7-0
//       RAX           EAX            AX            AH           AL
//       RBX           EBX            BX            BH           BL
//       RCX           ECX            CX            CH           CL
//       RDX           EDX            DX            DH           DL
//       RSI           ESI            SI                        SIL
//       RDI           EDI            DI                        DIL
//       RBP           EBP            BP                        BPL
//       RSP           ESP            SP                        SPL
//        R8           R8D           R8W                        R8B
//        R9           R9D           R9W                        R9B
//       R10          R10D          R10W                       R10B
//       R11          R11D          R11W                       R11B
//       R12          R12D          R12W                       R12B
//       R13          R13D          R13W                       R13B
//       R14          R14D          R14W                       R14B
//       R15          R15D          R15W                       R15B
//Их слишком много чтобы запоминать их все)
//Скорее всего вам хватит rax rdx rcx rdx и rsi и возможно r10-r15

//Это были регистры общего пользования. Зачастую их хватает.
//Остальное вы узнаете сами по мере погружения. Буду честен - сам мало знаю.

//Важно знать, что каждая инструкция требует входных значений в определенных регистрах.
//О чём вы можете прочитать по ссылке оставленной в README.md.

//==========ПРАКТИКА=========

//Что такое стек и куча пока не имеет смысла рассматривать. Просто потому, что сейчас
//вам эта информация мало что даст. Это понадобится когда функции перестанут умещаться
//в 24 строки на Zig. Ну и когда речь зайдёт об указателях и рекурсиях.

test "Первейший тест" {
//Тесты писать проще, да и проверять тоже. Позже будет переход к более переиспользуемым
//способам

  const result = asm volatile(
      ""
      : [ret]  "={rax}"  ( -> i64 ) //Тут output из rax
      : //Тут input   
      : .{} //clobbers - слово которое не имеет вменяемого перевода
  );

  //Да. Можно даже без ассемблерных инструкций.
  //Если вы смотрели код std. Могли заметить, что там любят такой подход
  //Буду честен - мне он тоже нравится. Он более простой
  std_lib.debug.print("\n{d}\n", .{result});

  //А теперь сделаем интереснее. Поместим значение в rax и достанем оттуда же

  const result2 = asm volatile(
      ""
      : [ret]  "={rax}"  ( -> i64 )
      : [_]    "{rax}"  ( 10 )
      : .{ .rax = true }
  );
  //Ещё интереснее)
  //То что в [ ] - воспринимайте как псевдонимы
  //Вы можете задать так псевдоним и использовать его

  //Из практики стандартной библиотеки zig - возвращаемое значение принято обозначать как [ret]
  //Несмотря на то, что этот "псевдоним" не используется

  try expect( result2 == 10 );

  //Теперь стоит показать использование псевдонимов, и инструкцию
  //Пусть будет add (сложение)

  const result3 = asm volatile(
      \\add     %[value],    %%rax // rax = value + rax
      : [ret]   "={rax}"   ( -> i64 )
      : [_]     "{rax}"    ( 10 ),
        [value] "r"        ( 20 ) //здесь r - любой регистр
                                  //Конкретно тут всёравно с каким регистром складывать
                                  //Поэтому можно просто использовать "r", довериться
                                  //компилятору, так сказать
      : .{ .rax = true }
  );

  try expect( result3 == 30 );

  //Можно сделать тоже самое, но точно указав какие регистры хотим сложить
  const result4 = asm volatile(
      \\add    %%rsi,    %%rax
      : [ret]  "={rax}"  ( -> u64 ) //Тут может быть любой тип. Лишь бы он умещался в длинну rax
      : [_]    "{rax}"  ( 9 ),
        [_]    "{rsi}"  ( 7 )
      : .{ .rax = true, .rsi = true }
  );

  //Оба варианта валидны и имеют право на жизнь.
  //Вопрос исключительно личных предпочтений.
  try expect( result4 == 16 );

}

test "Взаимодействеи со значениями из вне" {
  //Заготовка
  var a: i64 = 0;

  //Теперь поменяем значение переменной через ассемблерную вставку
  asm volatile(
    ""
      : [ret]  "={rax}"  ( a )
      : [_]    "{rax}"  ( 10 )
      : .{ .rax = true }
  );
  try expect( a == 10 );
  //Да. Вот так вот просто
  //Опять таки, для многих фокусов даже не надо писать инструкции
  //Можно и так.
  //Это я к тому, что чаще всего есть 2 инструкции а остальное - условия для этих инструкций.

  //Банальнийший пример - print hello word
  //Вы уже знаете достаточно чтобы его сделать
  //Лично для меня было удивлением что сискол - это целая ассемблерная инструкция

  const string = "\nСтрока для вывода\n";
  asm volatile(
      \\syscall
      :
      //Ничего нового для вас. Заполняем входные параметры
      //Этоит системный вызов ничего не возвращает. Поэтому вывод оставим пустым
      : [_] "{rax}" (1), //номер системного вызова
        [_] "{rdi}" (1), //stdout
        [_] "{rsi}" (&string[0]), //Указатель на начало строки
        [_] "{rdx}" (string.len)  //Длинна строки
      : .{ .rax = true,
           .rdi = true,
           .rsi = true,
          .rdx = true } );
  //Всё это вы уже видели. Вопрос лишь в умелом комбенировании всего этого
  //с другими инструкциями и командами.

  //Если у вас возник вопрос - почему сисколл - отдельная ассемблерная инструкция?
  //То это очень хорошо. Это значит вам интересна эта тема и как оно всё устроенно
  //Но моих знаний недостаточно для ответа. Лишь рекомендую самостоятельно продолжить поиски

}
